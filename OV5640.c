/***********************************************************************
 *                                                                     
 * Project: Balthazar
 * $Date: 2013/10/04 $
 * $Author: pfitger $
 *
 * $Id: //depot/Balthazar/Camera/OS/Experimental/linux/drivers/vcam/MT9P111.c#1 $
 *
 * Description of file:
 *   Visual Camera Driver
 *
 * Last check-in changelist:
 * $Change: 179282 $
 *
 * Copyright: FLIR Systems AB
 ***********************************************************************/

#include "flir_kernel_os.h"
#include "vcam_internal.h"
#include "i2cdev.h"
#include <linux/i2c.h>

// Local typedefs

typedef enum {CAM_1, CAM_2, CAM_ALL} CAM_NO;

// Local definitions

#define DEBUG_TMO           0

// Local functions

// Local variables
static BOOL bCamActive[CAM_ALL] = { TRUE, FALSE };

struct reg_value {
    u16 u16RegAddr;
    u8 u8Val;
};

/*Settings from
/Rocky/Elektronik/Komponenter/datablad/VCam/Settings/
*/
static struct reg_value ov5640_init_setting_15fps_5MP[] =
{
    {0x3103,0x11 },
    {0x3008,0x82 },
    {0x3008,0x42 },
    {0x3103,0x03 },
    {0x3017,0x00 },
    {0x3018,0x00 },
    {0x3034,0x18 },
    {0x3035,0x11 },
    {0x3036,0x54 },
    {0x3037,0x13 },
    {0x3108,0x01 },
    {0x3630,0x36 },
    {0x3631,0x0e },
    {0x3632,0xe2 },
    {0x3633,0x12 },
    {0x3621,0xe0 },
    {0x3704,0xa0 },
    {0x3703,0x5a },
    {0x3715,0x78 },
    {0x3717,0x01 },
    {0x370b,0x60 },
    {0x3705,0x1a },
    {0x3905,0x02 },
    {0x3906,0x10 },
    {0x3901,0x0a },
    {0x3731,0x12 },
    {0x3600,0x08 },
    {0x3601,0x33 },
    {0x302d,0x60 },
    {0x3620,0x52 },
    {0x371b,0x20 },
    {0x471c,0x50 },
    {0x3a13,0x43 },
    {0x3a18,0x00 },
    {0x3a19,0xf8 },
    {0x3635,0x13 },
    {0x3636,0x03 },
    {0x3634,0x40 },
    {0x3622,0x01 },
    {0x3c01,0x34 },
    {0x3c04,0x28 },
    {0x3c05,0x98 },
    {0x3c06,0x00 },
    {0x3c07,0x07 },
    {0x3c08,0x00 },
    {0x3c09,0x1c },
    {0x3c0a,0x9c },
    {0x3c0b,0x40 },
    {0x3820,0x40 },
    {0x3821,0x06 },
    {0x3814,0x11 },
    {0x3815,0x11 },
    {0x3800,0x00 },
    {0x3801,0x00 },
    {0x3802,0x00 },
    {0x3803,0x00 },
    {0x3804,0x0a },
    {0x3805,0x3f },
    {0x3806,0x07 },
    {0x3807,0x9f },
    {0x3808,0x0a },
    {0x3809,0x20 },
    {0x380a,0x07 },
    {0x380b,0x98 },
    {0x380c,0x0b },
    {0x380d,0x1c },
    {0x380e,0x07 },
    {0x380f,0xb0 },
    {0x3810,0x00 },
    {0x3811,0x10 },
    {0x3812,0x00 },
    {0x3813,0x04 },
    {0x3618,0x04 },
    {0x3612,0x2b },
    {0x3708,0x64 },
    {0x3709,0x12 },
    {0x370c,0x00 },
    {0x3a02,0x07 },
    {0x3a03,0xb0 },
    {0x3a08,0x01 },
    {0x3a09,0x27 },
    {0x3a0a,0x00 },
    {0x3a0b,0xf6 },
    {0x3a0e,0x06 },
    {0x3a0d,0x08 },
    {0x3a14,0x07 },
    {0x3a15,0xb0 },
    {0x4001,0x02 },
    {0x4004,0x06 },
    {0x3000,0x00 },
    {0x3002,0x1c },
    {0x3004,0xff },
    {0x3006,0xc3 },
    {0x300e,0x45 },
    {0x302e,0x08 },
    {0x4300,0x30 },
    {0x4837,0x0a },
    {0x501f,0x00 },
    {0x440e,0x00 },
    {0x5000,0xa7 },
    {0x5001,0x83 },
    {0x5180,0xff },
    {0x5181,0xf2 },
    {0x5182,0x00 },
    {0x5183,0x14 },
    {0x5184,0x25 },
    {0x5185,0x24 },
    {0x5186,0x09 },
    {0x5187,0x09 },
    {0x5188,0x09 },
    {0x5189,0x75 },
    {0x518a,0x54 },
    {0x518b,0xe0 },
    {0x518c,0xb2 },
    {0x518d,0x42 },
    {0x518e,0x3d },
    {0x518f,0x56 },
    {0x5190,0x46 },
    {0x5191,0xf8 },
    {0x5192,0x04 },
    {0x5193,0x70 },
    {0x5194,0xf0 },
    {0x5195,0xf0 },
    {0x5196,0x03 },
    {0x5197,0x01 },
    {0x5198,0x04 },
    {0x5199,0x12 },
    {0x519a,0x04 },
    {0x519b,0x00 },
    {0x519c,0x06 },
    {0x519d,0x82 },
    {0x519e,0x38 },
    {0x5381,0x1e },
    {0x5382,0x5b },
    {0x5383,0x08 },
    {0x5384,0x0a },
    {0x5385,0x7e },
    {0x5386,0x88 },
    {0x5387,0x7c },
    {0x5388,0x6c },
    {0x5389,0x10 },
    {0x538a,0x01 },
    {0x538b,0x98 },
    {0x5300,0x08 },
    {0x5301,0x30 },
    {0x5302,0x10 },
    {0x5303,0x00 },
    {0x5304,0x08 },
    {0x5305,0x30 },
    {0x5306,0x08 },
    {0x5307,0x16 },
    {0x5309,0x08 },
    {0x530a,0x30 },
    {0x530b,0x04 },
    {0x530c,0x06 },
    {0x5480,0x01 },
    {0x5481,0x08 },
    {0x5482,0x14 },
    {0x5483,0x28 },
    {0x5484,0x51 },
    {0x5485,0x65 },
    {0x5486,0x71 },
    {0x5487,0x7d },
    {0x5488,0x87 },
    {0x5489,0x91 },
    {0x548a,0x9a },
    {0x548b,0xaa },
    {0x548c,0xb8 },
    {0x548d,0xcd },
    {0x548e,0xdd },
    {0x548f,0xea },
    {0x5490,0x1d },
    {0x5580,0x02 },
    {0x5583,0x40 },
    {0x5584,0x10 },
    {0x5589,0x10 },
    {0x558a,0x00 },
    {0x558b,0xf8 },
    {0x5800,0x23 },
    {0x5801,0x14 },
    {0x5802,0x0f },
    {0x5803,0x0f },
    {0x5804,0x12 },
    {0x5805,0x26 },
    {0x5806,0x0c },
    {0x5807,0x08 },
    {0x5808,0x05 },
    {0x5809,0x05 },
    {0x580a,0x08 },
    {0x580b,0x0d },
    {0x580c,0x08 },
    {0x580d,0x03 },
    {0x580e,0x00 },
    {0x580f,0x00 },
    {0x5810,0x03 },
    {0x5811,0x09 },
    {0x5812,0x07 },
    {0x5813,0x03 },
    {0x5814,0x00 },
    {0x5815,0x01 },
    {0x5816,0x03 },
    {0x5817,0x08 },
    {0x5818,0x0d },
    {0x5819,0x08 },
    {0x581a,0x05 },
    {0x581b,0x06 },
    {0x581c,0x08 },
    {0x581d,0x0e },
    {0x581e,0x29 },
    {0x581f,0x17 },
    {0x5820,0x11 },
    {0x5821,0x11 },
    {0x5822,0x15 },
    {0x5823,0x28 },
    {0x5824,0x46 },
    {0x5825,0x26 },
    {0x5826,0x08 },
    {0x5827,0x26 },
    {0x5828,0x64 },
    {0x5829,0x26 },
    {0x582a,0x24 },
    {0x582b,0x22 },
    {0x582c,0x24 },
    {0x582d,0x24 },
    {0x582e,0x06 },
    {0x582f,0x22 },
    {0x5830,0x40 },
    {0x5831,0x42 },
    {0x5832,0x24 },
    {0x5833,0x26 },
    {0x5834,0x24 },
    {0x5835,0x22 },
    {0x5836,0x22 },
    {0x5837,0x26 },
    {0x5838,0x44 },
    {0x5839,0x24 },
    {0x583a,0x26 },
    {0x583b,0x28 },
    {0x583c,0x42 },
    {0x583d,0xce },
    {0x5025,0x00 },
    {0x3a0f,0x30 },
    {0x3a10,0x28 },
    {0x3a1b,0x30 },
    {0x3a1e,0x26 },
    {0x3a11,0x60 },
    {0x3a1f,0x14 },
    {0x3008,0x02 }
};
static struct reg_value ov5640_init_setting_30fps_VGA[] = {

    {0x3103, 0x11}, {0x3008, 0x82}, {0x3008, 0x42},
    {0x3103, 0x03}, {0x3017, 0x00}, {0x3018, 0x00},
    {0x3034, 0x18}, {0x3035, 0x14}, {0x3036, 0x38},
    {0x3037, 0x13}, {0x3108, 0x01}, {0x3630, 0x36},
    {0x3631, 0x0e}, {0x3632, 0xe2}, {0x3633, 0x12},
    {0x3621, 0xe0}, {0x3704, 0xa0}, {0x3703, 0x5a},
    {0x3715, 0x78}, {0x3717, 0x01}, {0x370b, 0x60},
    {0x3705, 0x1a}, {0x3905, 0x02}, {0x3906, 0x10},
    {0x3901, 0x0a}, {0x3731, 0x12}, {0x3600, 0x08},
    {0x3601, 0x33}, {0x302d, 0x60}, {0x3620, 0x52},
    {0x371b, 0x20}, {0x471c, 0x50}, {0x3a13, 0x43},
    {0x3a18, 0x00}, {0x3a19, 0xf8}, {0x3635, 0x13},
    {0x3636, 0x03}, {0x3634, 0x40}, {0x3622, 0x01},
    {0x3c01, 0xa4}, {0x3c04, 0x28}, {0x3c05, 0x98},
    {0x3c06, 0x00}, {0x3c07, 0x08}, {0x3c08, 0x00},
    {0x3c09, 0x1c}, {0x3c0a, 0x9c}, {0x3c0b, 0x40},
    {0x3820, 0x41}, {0x3821, 0x07}, {0x3814, 0x31},
    {0x3815, 0x31}, {0x3800, 0x00}, {0x3801, 0x00},
    {0x3802, 0x00}, {0x3803, 0x04}, {0x3804, 0x0a},
    {0x3805, 0x3f}, {0x3806, 0x07}, {0x3807, 0x9b},
    {0x3808, 0x02}, {0x3809, 0x80}, {0x380a, 0x01},
    {0x380b, 0xe0}, {0x380c, 0x07}, {0x380d, 0x68},
    {0x380e, 0x03}, {0x380f, 0xd8}, {0x3810, 0x00},
    {0x3811, 0x10}, {0x3812, 0x00}, {0x3813, 0x06},
    {0x3618, 0x00}, {0x3612, 0x29}, {0x3708, 0x64},
    {0x3709, 0x52}, {0x370c, 0x03}, {0x3a02, 0x03},
    {0x3a03, 0xd8}, {0x3a08, 0x01}, {0x3a09, 0x27},
    {0x3a0a, 0x00}, {0x3a0b, 0xf6}, {0x3a0e, 0x03},
    {0x3a0d, 0x04}, {0x3a14, 0x03}, {0x3a15, 0xd8},
    {0x4001, 0x02}, {0x4004, 0x02}, {0x3000, 0x00},
    {0x3002, 0x1c}, {0x3004, 0xff}, {0x3006, 0xc3},
    {0x300e, 0x45}, {0x302e, 0x08}, {0x4300, 0x3f},
    {0x501f, 0x00}, {0x4713, 0x03}, {0x4407, 0x04},
    {0x440e, 0x00}, {0x460b, 0x35}, {0x460c, 0x22},
    {0x4837, 0x0a}, {0x4800, 0x04}, {0x3824, 0x02},
    {0x5000, 0xa7}, {0x5001, 0xa3}, {0x5180, 0xff},
    {0x5181, 0xf2}, {0x5182, 0x00}, {0x5183, 0x14},
    {0x5184, 0x25}, {0x5185, 0x24}, {0x5186, 0x09},
    {0x5187, 0x09}, {0x5188, 0x09}, {0x5189, 0x88},
    {0x518a, 0x54}, {0x518b, 0xee}, {0x518c, 0xb2},
    {0x518d, 0x50}, {0x518e, 0x34}, {0x518f, 0x6b},
    {0x5190, 0x46}, {0x5191, 0xf8}, {0x5192, 0x04},
    {0x5193, 0x70}, {0x5194, 0xf0}, {0x5195, 0xf0},
    {0x5196, 0x03}, {0x5197, 0x01}, {0x5198, 0x04},
    {0x5199, 0x6c}, {0x519a, 0x04}, {0x519b, 0x00},
    {0x519c, 0x09}, {0x519d, 0x2b}, {0x519e, 0x38},
    {0x5381, 0x1e}, {0x5382, 0x5b}, {0x5383, 0x08},
    {0x5384, 0x0a}, {0x5385, 0x7e}, {0x5386, 0x88},
    {0x5387, 0x7c}, {0x5388, 0x6c}, {0x5389, 0x10},
    {0x538a, 0x01}, {0x538b, 0x98}, {0x5300, 0x08},
    {0x5301, 0x30}, {0x5302, 0x10}, {0x5303, 0x00},
    {0x5304, 0x08}, {0x5305, 0x30}, {0x5306, 0x08},
    {0x5307, 0x16}, {0x5309, 0x08}, {0x530a, 0x30},
    {0x530b, 0x04}, {0x530c, 0x06}, {0x5480, 0x01},
    {0x5481, 0x08}, {0x5482, 0x14}, {0x5483, 0x28},
    {0x5484, 0x51}, {0x5485, 0x65}, {0x5486, 0x71},
    {0x5487, 0x7d}, {0x5488, 0x87}, {0x5489, 0x91},
    {0x548a, 0x9a}, {0x548b, 0xaa}, {0x548c, 0xb8},
    {0x548d, 0xcd}, {0x548e, 0xdd}, {0x548f, 0xea},
    {0x5490, 0x1d}, {0x5580, 0x02}, {0x5583, 0x40},
    {0x5584, 0x10}, {0x5589, 0x10}, {0x558a, 0x00},
    {0x558b, 0xf8}, {0x5800, 0x23}, {0x5801, 0x14},
    {0x5802, 0x0f}, {0x5803, 0x0f}, {0x5804, 0x12},
    {0x5805, 0x26}, {0x5806, 0x0c}, {0x5807, 0x08},
    {0x5808, 0x05}, {0x5809, 0x05}, {0x580a, 0x08},
    {0x580b, 0x0d}, {0x580c, 0x08}, {0x580d, 0x03},
    {0x580e, 0x00}, {0x580f, 0x00}, {0x5810, 0x03},
    {0x5811, 0x09}, {0x5812, 0x07}, {0x5813, 0x03},
    {0x5814, 0x00}, {0x5815, 0x01}, {0x5816, 0x03},
    {0x5817, 0x08}, {0x5818, 0x0d}, {0x5819, 0x08},
    {0x581a, 0x05}, {0x581b, 0x06}, {0x581c, 0x08},
    {0x581d, 0x0e}, {0x581e, 0x29}, {0x581f, 0x17},
    {0x5820, 0x11}, {0x5821, 0x11}, {0x5822, 0x15},
    {0x5823, 0x28}, {0x5824, 0x46}, {0x5825, 0x26},
    {0x5826, 0x08}, {0x5827, 0x26}, {0x5828, 0x64},
    {0x5829, 0x26}, {0x582a, 0x24}, {0x582b, 0x22},
    {0x582c, 0x24}, {0x582d, 0x24}, {0x582e, 0x06},
    {0x582f, 0x22}, {0x5830, 0x40}, {0x5831, 0x42},
    {0x5832, 0x24}, {0x5833, 0x26}, {0x5834, 0x24},
    {0x5835, 0x22}, {0x5836, 0x22}, {0x5837, 0x26},
    {0x5838, 0x44}, {0x5839, 0x24}, {0x583a, 0x26},
    {0x583b, 0x28}, {0x583c, 0x42}, {0x583d, 0xce},
    {0x5025, 0x00}, {0x3a0f, 0x30}, {0x3a10, 0x28},
    {0x3a1b, 0x30}, {0x3a1e, 0x26}, {0x3a11, 0x60},
    {0x3a1f, 0x14}, {0x3008, 0x02}, {0x3c00, 0x04},
};

static struct reg_value ov5640_setting_30fps_VGA_640_480[] = {

    {0x3035, 0x14}, {0x3036, 0x38}, {0x3c07, 0x08},
    {0x3c09, 0x1c}, {0x3c0a, 0x9c}, {0x3c0b, 0x40},
    {0x3820, 0x41}, {0x3821, 0x07}, {0x3814, 0x31},
    {0x3815, 0x31}, {0x3800, 0x00}, {0x3801, 0x00},
    {0x3802, 0x00}, {0x3803, 0x04}, {0x3804, 0x0a},
    {0x3805, 0x3f}, {0x3806, 0x07}, {0x3807, 0x9b},
    {0x3808, 0x02}, {0x3809, 0x80}, {0x380a, 0x01},
    {0x380b, 0xe0}, {0x380c, 0x07}, {0x380d, 0x68},
    {0x380e, 0x04}, {0x380f, 0x38}, {0x3810, 0x00},
    {0x3811, 0x10}, {0x3812, 0x00}, {0x3813, 0x06},
    {0x3618, 0x00}, {0x3612, 0x29}, {0x3708, 0x64},
    {0x3709, 0x52}, {0x370c, 0x03}, {0x3a02, 0x03},
    {0x3a03, 0xd8}, {0x3a08, 0x01}, {0x3a09, 0x0e},
    {0x3a0a, 0x00}, {0x3a0b, 0xf6}, {0x3a0e, 0x03},
    {0x3a0d, 0x04}, {0x3a14, 0x03}, {0x3a15, 0xd8},
    {0x4001, 0x02}, {0x4004, 0x02}, {0x4713, 0x03},
    {0x4407, 0x04}, {0x460b, 0x35}, {0x460c, 0x22},
    {0x3824, 0x02}, {0x5001, 0xa3}, {0x3503, 0x00},
};

static struct reg_value ov5640_setting_30fps_720P_1280_720[] = {
    {0x3008, 0x42},
    {0x3035, 0x21}, {0x3036, 0x54}, {0x3c07, 0x07},
    {0x3c09, 0x1c}, {0x3c0a, 0x9c}, {0x3c0b, 0x40},
    {0x3820, 0x41}, {0x3821, 0x07}, {0x3814, 0x31},
    {0x3815, 0x31}, {0x3800, 0x00}, {0x3801, 0x00},
    {0x3802, 0x00}, {0x3803, 0xfa}, {0x3804, 0x0a},
    {0x3805, 0x3f}, {0x3806, 0x06}, {0x3807, 0xa9},
    {0x3808, 0x05}, {0x3809, 0x00}, {0x380a, 0x02},
    {0x380b, 0xd0}, {0x380c, 0x07}, {0x380d, 0x64},
    {0x380e, 0x02}, {0x380f, 0xe4}, {0x3810, 0x00},
    {0x3811, 0x10}, {0x3812, 0x00}, {0x3813, 0x04},
    {0x3618, 0x00}, {0x3612, 0x29}, {0x3708, 0x64},
    {0x3709, 0x52}, {0x370c, 0x03}, {0x3a02, 0x02},
    {0x3a03, 0xe4}, {0x3a08, 0x01}, {0x3a09, 0xbc},
    {0x3a0a, 0x01}, {0x3a0b, 0x72}, {0x3a0e, 0x01},
    {0x3a0d, 0x02}, {0x3a14, 0x02}, {0x3a15, 0xe4},
    {0x4001, 0x02}, {0x4004, 0x02}, {0x4713, 0x02},
    {0x4407, 0x04}, {0x460b, 0x37}, {0x460c, 0x20},
    {0x3824, 0x04}, {0x5001, 0x83}, {0x4005, 0x1a},
    {0x3008, 0x02}, {0x3503, 0},
};

/*
     Configure vcam for 1280x960.
     No scaling from full sensor image, instead cut out center image.
     See OV5640 datasheet image windowing configuration for more information

    (X_address_end - DVP_width) / 2 = ISP_horizontal_offset
    (2623 - 1280) / 2 = 671 = 0x2a3
    (Y_address_end - DVP_height) / 2 = ISP_vertical_offset
    (1951 - 960) / 2 = 495 = 0x1ef

*/
static struct reg_value ov5640_setting_30fps_1280_960[] = {
    {0x3008, 0x42},
    {0x3035, 0x21}, {0x3036, 0x54}, {0x3c07, 0x07},
    {0x3c09, 0x1c}, {0x3c0a, 0x9c}, {0x3c0b, 0x40},
    {0x3820, 0x41}, {0x3821, 0x07}, {0x3814, 0x31},
    {0x3815, 0x31},
    {0x3800, 0x00}, {0x3801, 0x00}, //X address start = 0
    {0x3802, 0x00}, {0x3803, 0x00}, //Y address start = 0
    {0x3804, 0x0a}, {0x3805, 0x3f}, //X address end   = 0xa3f (2623)
    {0x3806, 0x07}, {0x3807, 0x9f}, //Y address end   = 0x79f (1951)
    {0x3808, 0x05}, {0x3809, 0x00}, //DVP width  output size = 0x500   (1280)
    {0x380a, 0x03}, {0x380b, 0xc0}, //DVP height output size = 0x3c0   (960)
    {0x380c, 0x0b}, {0x380d, 0x1c}, // Total horizontal size = 0xb1c
    {0x380e, 0x07}, {0x380f, 0xb0}, // Total vertical size  =  0x7b0
    {0x3810, 0x02}, {0x3811, 0xa3}, // ISP horizontal offset = 0x2a3
    {0x3812, 0x01}, {0x3813, 0xef}, // ISP vertical   offset = 0x1ef
    {0x3618, 0x00}, {0x3612, 0x29}, {0x3708, 0x64},
    {0x3709, 0x52}, {0x370c, 0x03}, {0x3a02, 0x02},
    {0x3a03, 0xe4}, {0x3a08, 0x01}, {0x3a09, 0xbc},
    {0x3a0a, 0x01}, {0x3a0b, 0x72}, {0x3a0e, 0x01},
    {0x3a0d, 0x02}, {0x3a14, 0x02}, {0x3a15, 0xe4},
    {0x4001, 0x02}, {0x4004, 0x02}, {0x4713, 0x02},
    {0x4407, 0x04}, {0x460b, 0x37}, {0x460c, 0x20},
    {0x3824, 0x04}, {0x5001, 0x83}, {0x4005, 0x1a},
    {0x3008, 0x02}, {0x3503, 0},
};


static BOOL DoI2CWrite (PCAM_HW_INDEP_INFO pInfo,
                        struct reg_value  *pMode,
						USHORT elements,
						CAM_NO camera)
{
    struct i2c_msg msgs[1];
    int i, retval = 0;
    int retries = 50;
    DWORD cam;
    DWORD cam_first = (camera == CAM_2) ? CAM_2 : CAM_1;
    DWORD cam_last = (camera == CAM_1) ? CAM_1 : CAM_2;
    u8 buf[3] = {0};
    u16 RegAddr = 0;
    u8  Val = 0;

    for (cam=cam_first; cam<=cam_last; cam++)
    {
        // Check if camera in use
        msgs[0].addr = pInfo->cameraI2CAddress[cam] >> 1;
        if (msgs[0].addr == 0)
            continue;
        msgs[0].flags = 0;
        msgs[0].buf = buf;
        msgs[0].len = 3;


        for (i=0; i<elements;++i)
        {
            RegAddr = pMode[i].u16RegAddr;
            Val     = pMode[i].u8Val;

            buf[0] = RegAddr >> 8;
            buf[1] = RegAddr & 0xff;
            buf[2] = Val;

            retval = i2c_transfer(pInfo->hI2C, msgs, 1);

  //        pr_err("DoI2CWrite i %d  regaddr %x value %x cam %d i2caddr %x \n",i,RegAddr,Val,cam,pInfo->cameraI2CAddress[cam]);
            if (retval <= 0)
            {
                if (retries-- <= 0)
                {
                    pr_err("VCAM: DoI2CWrite failing on element %d of %d\n", i, elements);
                    return FALSE;       // Too many errors, give up
                }
                msleep (10);
                i--;
                continue;
            }
        }
    }

    return TRUE;
}
#if 0
static BOOL DoI2CRead (PCAM_HW_INDEP_INFO pInfo, USHORT *result, USHORT reg, CAM_NO camera)
{
	struct i2c_msg msgs[2];
    DWORD ret = 0;
    UCHAR cmd[2];
    UCHAR stat[2];

    // Check if camera in use
    msgs[0].addr = BSPGetCameraI2CAddress(camera) >> 1;
    if (msgs[0].addr == 0)
        return TRUE;
    msgs[1].addr = msgs[0].addr;

    msgs[0].flags = 0;
    msgs[0].len = 2;
    msgs[0].buf = cmd;
    msgs[1].flags = I2C_M_RD | I2C_M_NOSTART;
    msgs[1].len = 2;
    msgs[1].buf = stat;

    cmd[0] = (UCHAR)(reg >> 8);
    cmd[1] = (UCHAR)(reg & 0xFF);

    ret = i2c_transfer(pInfo->hI2C, msgs, 2);

    if (ret > 0)
    {
        *result = (stat[0] << 8) | stat[1];
    }
    else
    {
        pr_err("DoI2CRead failing reading reg %d\n", reg);
    }
    return ret;
}
#endif


void OV5640_stream_on(PCAM_HW_INDEP_INFO pInfo,CAM_NO camera)
{
    struct reg_value buff= {0x4202,0};
    DoI2CWrite(pInfo,&buff,1,camera);
}

void OV5640_stream_off(PCAM_HW_INDEP_INFO pInfo,CAM_NO camera)
{
    struct reg_value buff= {0x4202,0x0f};
    DoI2CWrite(pInfo,&buff,1,camera);
}


static BOOL initCamera (PCAM_HW_INDEP_INFO pInfo, BOOL fullInit, CAM_NO cam)
{
    BOOL ret = TRUE;

    ret = DoI2CWrite(pInfo, ov5640_init_setting_15fps_5MP, dim(ov5640_init_setting_15fps_5MP), cam);
    if(ret)
         return ret;
//    ret = DoI2CWrite(pInfo, ov5640_init_setting_30fps_VGA, dim(ov5640_init_setting_30fps_VGA), cam);
//    if(ret)
//       return ret;
//    ret = DoI2CWrite(pInfo, ov5640_setting_30fps_VGA_640_480, dim(ov5640_setting_30fps_VGA_640_480), cam);
//    if(ret)
//       return ret;

//    OV5640_stream_off(pInfo,cam);
//    ret = DoI2CWrite(pInfo, ov5640_setting_30fps_1280_960, dim(ov5640_setting_30fps_1280_960), cam);
//    if(ret)
//       return ret;
//    OV5640_stream_on(pInfo,cam);

	return ret;
}

BOOL OV5640_Init(PCAM_HW_INDEP_INFO pInfo)
{
    initCamera(pInfo, TRUE, CAM_ALL);
    /*if (bCamActive[CAM_1] == FALSE)
		DoI2CWrite(pInfo, I2CDataStandByEnter[0], dim(I2CDataStandByEnter), 0, 0, 0, CAM_1);
	if (bCamActive[CAM_2] == FALSE)
		DoI2CWrite(pInfo, I2CDataStandByEnter[0], dim(I2CDataStandByEnter), 0, 0, 0, CAM_2);
    */
    return TRUE;
}

DWORD OV5640_IOControl(PCAM_HW_INDEP_INFO pInfo,
                        DWORD  Ioctl,
                        PUCHAR pBuf,
                        PUCHAR pUserBuf)
{
    DWORD  dwErr = ERROR_INVALID_PARAMETER;
    static BOOL bTestActive;

    switch (Ioctl) 
	{
        case IOCTL_CAM_GET_TEST:   
			{
	   			LOCK(pInfo);
                ((VCAMIOCTLTEST *)pBuf)->bTestMode = bTestActive;
				dwErr = ERROR_SUCCESS;
        		UNLOCK(pInfo);
   			}
            break;

		case IOCTL_CAM_SET_TEST:
            {
			    LOCK(pInfo);
				bTestActive = (((VCAMIOCTLTEST *)pBuf)->bTestMode != 0);
				dwErr = ERROR_SUCCESS;
			    UNLOCK(pInfo);
            }
            break;

		case IOCTL_CAM_GET_ACTIVE:   
            {
				VCAMIOCTLACTIVE * pVcamIoctl = (VCAMIOCTLACTIVE *)pBuf;
    			LOCK(pInfo);
				pVcamIoctl->bActive = bCamActive[CAM_1] || bCamActive[CAM_2];
				dwErr = ERROR_SUCCESS;
        		UNLOCK(pInfo);
   			}
            break;


        case IOCTL_CAM_INIT:
            dwErr = ERROR_SUCCESS;
            break;

		case IOCTL_CAM_SET_ACTIVE:
		case IOCTL_CAM_SET_2ND_ACTIVE:
            {
				BOOL bNewActive;
				BOOL res = TRUE;
				CAM_NO cam = (Ioctl == IOCTL_CAM_SET_ACTIVE) ? CAM_1 : CAM_2;
    			LOCK(pInfo);
				bNewActive = (((VCAMIOCTLACTIVE *)pBuf)->bActive != 0);
				if (bNewActive != bCamActive[cam])
				{
					if (bNewActive)
					{
                    //	res = DoI2CWrite(pInfo, I2CDataStandByExit[0], dim(I2CDataStandByExit), 0, 0, 0, cam);

					}
					else
					{
                    //	res = DoI2CWrite(pInfo, I2CDataStandByEnter[0], dim(I2CDataStandByEnter), 0, 0, 0, cam);
					}
				}

				if (res)
				{
					bCamActive[cam] = bNewActive;
					pr_err("bCamActive for cam %d now %d\n", cam, bCamActive[cam]);
					dwErr = ERROR_SUCCESS;
				}
        		UNLOCK(pInfo);
            }
            break;

		case IOCTL_CAM_SET_FLASH:
            {
				VCAMIOCTLFLASH * pFlashData = (VCAMIOCTLFLASH *) pBuf;
			    LOCK(pInfo);

				if (pFlashData->bFlashOn)
				{
				}

				dwErr = pInfo->pSetTorchState(pInfo, pFlashData);
			    UNLOCK(pInfo);
            }
            break;

        case IOCTL_CAM_GRAB_STILL:
            {
              //  CAM_NO cam = (bCamActive[CAM_1] == TRUE) ? CAM_1 : CAM_2;

    			LOCK(pInfo);
                // Tell camera to switch to context B
                //DoI2CWrite(pInfo, I2CDataGrab[0], dim(I2CDataGrab), 0, 0, 0, cam);

                dwErr = ERROR_SUCCESS;
    			UNLOCK(pInfo);
            }
            break;

		default:
			pr_err("VCAM Unsupported IOCTL code %lu\n", Ioctl);
			dwErr = ERROR_NOT_SUPPORTED;
			break;
    }
	
    return dwErr;
}



